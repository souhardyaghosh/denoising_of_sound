# -*- coding: utf-8 -*-
"""signals.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rjAaMageCDlgdlDkKUTWssyOKiNbbFiJ
"""



from google.colab import drive
drive.mount('/content/drive')

import gdown

# First file
gdown.download('https://drive.google.com/uc?id=1mIsEZ_CsZwx5EYjS9wrz-Xnmmft6GAKh', 'file1.mp3', quiet=False)

# Second file
gdown.download('https://drive.google.com/uc?id=1RRKi0KQOkzs6H62Da29eWMraCMwag4sf', 'file2.mp3', quiet=False)

from IPython.display import Audio

# Play the first file = Main Audio
Audio('file1.mp3')

# Play the second file = Noise
Audio('file2.mp3')

!pip install librosa

import librosa
import matplotlib.pyplot as plt
import numpy as np

# Load the audio file
audio_file = 'file1.mp3'
y, sr = librosa.load(audio_file, sr=None)  # y is the audio time series, sr is the sample rate

# Plot the discrete audio signal
plt.figure(figsize=(14, 5))
plt.stem(np.arange(0, len(y)), y, markerfmt=" ", basefmt="-b", use_line_collection=True)
plt.xlabel('Sample Index')
plt.ylabel('Amplitude')
plt.title('Discrete Audio Signal')
plt.show()

import librosa
import matplotlib.pyplot as plt
import numpy as np

# Load the second audio file
audio_file_2 = 'file2.mp3'
y2, sr2 = librosa.load(audio_file_2, sr=None)  # y2 is the audio time series, sr2 is the sample rate

# Plot the discrete audio signal for the second file
plt.figure(figsize=(14, 5))
plt.stem(np.arange(0, len(y2)), y2, markerfmt=" ", basefmt="-b", use_line_collection=True)
plt.xlabel('Sample Index')
plt.ylabel('Amplitude')
plt.title('Discrete Audio Signal of Noise')
plt.show()

import librosa
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import Audio, display

# Load audio files
y1, sr1 = librosa.load('file1.mp3', sr=None)
y2, sr2 = librosa.load('file2.mp3', sr=None)

# Resample y2 to match sr1 if needed
if sr1 != sr2:
    y2 = librosa.resample(y2, orig_sr=sr2, target_sr=sr1)

# Ensure same length
if len(y1) != len(y2):
    if len(y1) > len(y2):
        y2 = np.pad(y2, (0, len(y1) - len(y2)))
    else:
        y1 = np.pad(y1, (0, len(y2) - len(y1)))
combined_audio = y1 + y2

# Plot and animate
fig, ax = plt.subplots(figsize=(14, 5))
x = np.arange(len(combined_audio))
ax.plot(x, combined_audio, color='blue')
playhead, = ax.plot([0, 0], [-1, 1], color='red')
ax.set_xlim([0, len(combined_audio)])
ax.set_ylim([-1, 1])

def update(frame):
    playhead.set_data([frame, frame], [-1, 1])
    return playhead,

display(Audio(combined_audio, rate=sr1, autoplay=True))
FuncAnimation(fig, update, frames=np.arange(0, len(combined_audio), int(sr1 / 30)), interval=30, blit=True)
plt.show()

import librosa
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import Audio, display
import soundfile as sf

# Load audio files
y1, sr1 = librosa.load('file1.mp3', sr=None)
y2, sr2 = librosa.load('file2.mp3', sr=None)

# Resample y2 to match sr1 if needed
if sr1 != sr2:
    y2 = librosa.resample(y2, orig_sr=sr2, target_sr=sr1)

# Ensure same length
if len(y1) != len(y2):
    if len(y1) > len(y2):
        y2 = np.pad(y2, (0, len(y1) - len(y2)))
    else:
        y1 = np.pad(y1, (0, len(y2) - len(y1)))
combined_audio = y1 + y2

# Save the combined audio as file3.mp3
sf.write('file3.wav', combined_audio, sr1)  # Saving as WAV format

# Plot and animate
fig, ax = plt.subplots(figsize=(14, 5))
x = np.arange(len(combined_audio))
ax.plot(x, combined_audio, color='blue')
playhead, = ax.plot([0, 0], [-1, 1], color='red')
ax.set_xlim([0, len(combined_audio)])
ax.set_ylim([-1, 1])

def update(frame):
    playhead.set_data([frame, frame], [-1, 1])
    return playhead,

display(Audio(combined_audio, rate=sr1, autoplay=True))
FuncAnimation(fig, update, frames=np.arange(0, len(combined_audio), int(sr1 / 30)), interval=30, blit=True)
plt.show()